import tkinter as tk
from tkinter import ttk
import serial
import struct
import threading
import time
import glob

# generated by chatgpt
# ONLY WORKS IN LINUX!!

# Available commands
COMMANDS = {
    "SET_DUTY": 0,
    "SET_CURRENT": 1,
    "SET_CURRENT_BRAKE": 2,
    "SET_RPM": 3,
    "SET_POS": 4,
    "SET_RPM_PID": 5,
    "SET_CURRENT_REL": 10,
    "SET_CURRENT_BRAKE_REL": 11,
    "SET_CURRENT_HANDBRAKE": 12,
    "SET_CURRENT_HANDBRAKE_REL": 13
}

# Available motors
MOTORS = {
    "Right": 1,
    "Left": 2,
    "Both": 3
}

# Function to automatically detect the correct serial port based on a handshake
def auto_detect_serial_port(baud_rate=460800, handshake_response_byte=0xA6, timeout=2):
    # Scan possible serial ports
    possible_ports = glob.glob('/dev/ttyACM*') + glob.glob('/dev/ttyUSB*')

    for port in possible_ports:
        try:
            print(f"Trying {port} for handshake...")
            conn = serial.Serial(port, baud_rate, timeout=1)

            if conn.is_open:
                if ping_device(conn, handshake_response_byte, timeout):
                    print(f"Handshake successful with device on {port}")
                    return conn  # Return the working serial connection
                else:
                    print(f"No valid response from {port} during handshake.")
            conn.close()  # Close the connection if handshake fails
        except serial.SerialException as e:
            print(f"Failed to connect to {port}: {e}")

    return None  # No valid ports found

# Function to send the handshake as a full 7-byte packet and verify the response with a timeout period
def ping_device(conn, handshake_response_byte, timeout=2):
    try:
        # Construct the 7-byte handshake packet (first byte is 0xA6, others are 0)
        handshake_packet = struct.pack('B', 0xA6) + b'\x00' * 6  # 0xA6 + six zeros

        conn.reset_input_buffer()  # Clear the input buffer before sending the handshake
        conn.write(handshake_packet)  # Send the full 7-byte packet
        start_time = time.time()  # Record the start time

        print(f"Sent handshake packet: {handshake_packet.hex()}")

        while (time.time() - start_time) < timeout:  # Keep reading until the timeout
            if conn.in_waiting > 0:  # Check if there's data to read
                response = conn.read(1)  # Read one byte at a time
                if response == bytes([handshake_response_byte]):
                    print(f"Handshake successful: Received {hex(handshake_response_byte)}")
                    return True
            time.sleep(0.001)  # Small delay to avoid excessive CPU usage, if too small will cause code to miss response

        print("Handshake failed: Timeout while waiting for response")
        return False
    except Exception as e:
        print(f"Error during handshake: {e}")
        return False

# Function to send a command with a float value over serial (7 bytes total)
def send_command(command_name, device_name, float_value, ser):
    # Get command and device values
    command_value = COMMANDS[command_name]
    device_value = MOTORS[device_name]

    # Combine device and command: device value is shifted into the top two bits
    packet_type = (device_value << 6) | command_value  # Top two bits for device, lower bits for command
    start_byte = 0xA5  # Start byte

    # Pack the float into bytes in little-endian format
    data = struct.pack('<f', float_value)  # '<f' for little-endian float

    # Calculate the checksum (sum of start_byte, packet_type, and float data bytes)
    checksum = (start_byte + packet_type + sum(data)) & 0xFF  # Simple checksum

    # Construct the 7-byte packet: start byte (1), command (1), float (4), checksum (1)
    packet = struct.pack('BB', start_byte, packet_type) + data + struct.pack('B', checksum)

    # Send the packet over serial
    if ser.isOpen():
        ser.write(packet)

# Function to continuously read and display all incoming data from the ESP32
def read_all_from_esp32(output_text_widget, rpm_right_widget, rpm_left_widget, encoder_angle_widget, ser):
    buffer = b''  # Buffer to accumulate partial reads if needed
    
    while True:
        if ser.in_waiting > 0:
            byte_data = ser.read(ser.in_waiting)
            buffer += byte_data  # Add the incoming data to the buffer
            
            # Process the buffer
            while buffer:
                if buffer[0] == 0xA5 and len(buffer) >= 7:  # Start byte detected, full packet available
                    # Parse RPM or encoder angle packet
                    packet = buffer[:7]  # Get the first 7 bytes for RPM or encoder angle packet
                    buffer = buffer[7:]  # Remove the processed packet from the buffer

                    # Unpack the packet
                    start_byte, command, data_value, checksum = struct.unpack('<BBfB', packet)

                    # Validate checksum
                    calculated_checksum = (start_byte + command + sum(packet[2:6])) & 0xFF
                    if calculated_checksum == checksum:
                        motor = (command >> 6)  # Extract motor from the top two bits of command
                        command_type = command & 0x3F  # Extract command from the lower six bits

                        if command_type == 3:  # Assuming command 3 is SET_RPM
                            if motor == 1:  # Right motor
                                rpm_right_widget.delete(0, tk.END)
                                rpm_right_widget.insert(0, f"{data_value:.2f}")
                            elif motor == 2:  # Left motor
                                rpm_left_widget.delete(0, tk.END)
                                rpm_left_widget.insert(0, f"{data_value:.2f}")

                        elif command_type == 40 and motor == 0:  # Command 40 is for encoder angle, motor side 0
                            encoder_angle_widget.delete(0, tk.END)
                            encoder_angle_widget.insert(0, f"{data_value:.2f}")

                else:
                    # It's not an RPM or encoder angle packet; treat it as debug text
                    try:
                        # Try to decode text up to the next start byte or till the end
                        end_index = buffer.find(b'\xA5')  # Find the next start byte
                        if end_index == -1:  # No start byte found, treat all as debug
                            debug_text = buffer.decode('utf-8', errors='ignore').strip()
                            buffer = b''  # Clear buffer after processing
                        else:
                            debug_text = buffer[:end_index].decode('utf-8', errors='ignore').strip()
                            buffer = buffer[end_index:]  # Keep everything from the start byte on
                        
                        if debug_text:
                            output_text_widget.insert(tk.END, f"{debug_text}\n")
                            output_text_widget.see(tk.END)
                    except UnicodeDecodeError:
                        buffer = b''  # Clear buffer if there are decoding issues
                        
        time.sleep(0.1)  # Add a slight delay to avoid excessive CPU usage

# Function to handle the send button press
def on_send_button_click(command_combobox, device_combobox, float_value_entry, ser):
    try:
        command_name = command_combobox.get()  # Get selected command
        device_name = device_combobox.get()  # Get selected device
        float_value = float(float_value_entry.get())
        send_command(command_name, device_name, float_value, ser)
    except ValueError:
        print("Invalid input! Please enter a valid float value.")

# Create the GUI window
def create_gui():
    root = tk.Tk()
    root.title("VESC Command Sender and Serial Receiver")

    # Auto-detect the serial port using a handshake
    ser = auto_detect_serial_port()
    if ser is None:
        print("No valid serial port found.")
        return

    # Input section
    input_frame = ttk.Frame(root)
    input_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")

    ttk.Label(input_frame, text="Command:").grid(row=0, column=0, padx=5, pady=5, sticky="w")

    # Dropdown for available commands
    command_combobox = ttk.Combobox(input_frame, values=list(COMMANDS.keys()))
    command_combobox.grid(row=0, column=1, padx=5, pady=5, sticky="w")
    command_combobox.current(5)  # Set default to first command

    ttk.Label(input_frame, text="Motor:").grid(row=1, column=0, padx=5, pady=5, sticky="w")

    # Dropdown for selecting the device
    device_combobox = ttk.Combobox(input_frame, values=list(MOTORS.keys()))
    device_combobox.grid(row=1, column=1, padx=5, pady=5, sticky="w")
    device_combobox.current(0)  # Set default to first device ("Right")

    ttk.Label(input_frame, text="Float Value:").grid(row=2, column=0, padx=5, pady=5, sticky="w")
    float_value_entry = ttk.Entry(input_frame, width=10)
    float_value_entry.grid(row=2, column=1, padx=5, pady=5, sticky="w")

    send_button = ttk.Button(input_frame, text="Send", command=lambda: on_send_button_click(command_combobox, device_combobox, float_value_entry, ser))
    send_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Output section
    output_frame = ttk.Frame(root)
    output_frame.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")

    output_text = tk.Text(output_frame, wrap="word", height=15, width=50)
    output_text.grid(row=0, column=0, padx=5, pady=5)

    # RPM and encoder angle display section
    rpm_frame = ttk.Frame(root)
    rpm_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew")

    ttk.Label(rpm_frame, text="Right Motor RPM:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
    rpm_right_entry = ttk.Entry(rpm_frame, width=10)
    rpm_right_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    ttk.Label(rpm_frame, text="Left Motor RPM:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
    rpm_left_entry = ttk.Entry(rpm_frame, width=10)
    rpm_left_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")

    ttk.Label(rpm_frame, text="Encoder Angle:").grid(row=2, column=0, padx=5, pady=5, sticky="w")
    encoder_angle_entry = ttk.Entry(rpm_frame, width=10)
    encoder_angle_entry.grid(row=2, column=1, padx=5, pady=5, sticky="w")

    root.grid_rowconfigure(1, weight=1)
    root.grid_columnconfigure(0, weight=1)

    # Start a thread to continuously read data from the ESP32
    read_thread = threading.Thread(target=read_all_from_esp32, args=(output_text, rpm_right_entry, rpm_left_entry, encoder_angle_entry, ser))
    read_thread.daemon = True  # This will allow the thread to close when the program exits
    read_thread.start()

    # Run the GUI event loop
    root.mainloop()

# Start the GUI
create_gui()
